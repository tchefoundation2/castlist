import { SiweMessage } from 'viem/siwe';
export { generateSiweNonce as generateNonce } from 'viem/siwe';
import { Result } from 'neverthrow';
import { Address, Client as Client$1, Hex } from 'viem';

interface AuthClientErrorOpts {
    message: string;
    cause: Error | AuthClientError;
    presentable: boolean;
}
declare class AuthClientError extends Error {
    readonly errCode: AuthClientErrorCode;
    readonly presentable: boolean;
    /**
     * @param errCode - the AuthClientError code for this message
     * @param context - a message, another Error, or a AuthClientErrorOpts
     */
    constructor(errCode: AuthClientErrorCode, context: Partial<AuthClientErrorOpts> | string | Error);
}
/**
 * AuthClientErrorCode defines all the types of errors that can be raised.
 *
 * A string union type is chosen over an enumeration since TS enums are unusual types that generate
 * javascript code and may cause downstream issues. See:
 * https://www.executeprogram.com/blog/typescript-features-to-avoid
 */
type AuthClientErrorCode = "unauthenticated" | "unauthorized" | "bad_request" | "bad_request.validation_failure" | "not_found" | "not_implemented" | "unavailable" | "unknown";
/** Type alias for shorthand when handling errors */
type AuthClientResult<T> = Result<T, AuthClientError>;
type AuthClientAsyncResult<T> = Promise<AuthClientResult<T>>;
type NoneOf<T> = {
    [K in keyof T]: never;
};
type Unwrapped<T> = (T & {
    isError: false;
    error?: never;
}) | (NoneOf<T> & {
    isError: true;
    error?: AuthClientError;
});
type AsyncUnwrapped<T> = Promise<Unwrapped<T>>;
declare const unwrap: <T>(result: AuthClientResult<T>) => Unwrapped<T>;

interface EthereumConnector {
    getFid: (custody: Address) => Promise<bigint>;
    isValidAuthAddress: (authAddress: Address, fid: bigint) => Promise<boolean>;
    publicClient: Client$1;
}

interface CreateClientArgs {
    relay?: string;
    version?: string;
    ethereum: EthereumConnector;
}
interface ClientConfig {
    relay: string;
    version?: string;
}
interface Client {
    config: ClientConfig;
    ethereum: EthereumConnector;
}
declare const createClient: ({ ethereum, ...config }: CreateClientArgs) => {
    config: {
        relay: string;
        version: string;
    };
    ethereum: EthereumConnector;
};

interface HttpOpts {
    authToken?: string;
    headers?: Record<string, string>;
}
interface PollOpts<ResponseDataType> {
    interval?: number;
    timeout?: number;
    successCode?: number;
    onResponse?: (response: HttpResponse<ResponseDataType>) => void;
}
interface HttpResponse<ResponseDataType> {
    response: Response;
    data: ResponseDataType;
}
type AsyncHttpResponse<T> = Promise<HttpResponse<T>>;
declare const get: <ResponseDataType>(client: Client, path: string, opts?: HttpOpts) => AuthClientAsyncResult<HttpResponse<ResponseDataType>>;
declare const post: <BodyType, ResponseDataType>(client: Client, path: string, json: BodyType, opts?: HttpOpts) => AuthClientAsyncResult<HttpResponse<ResponseDataType>>;
declare const poll: <ResponseDataType>(client: Client, path: string, pollOpts?: PollOpts<ResponseDataType> | undefined, opts?: HttpOpts) => AuthClientAsyncResult<HttpResponse<ResponseDataType>>;

type CreateChannelArgs = CreateChannelRequest;
type CreateChannelResponse = AsyncUnwrapped<HttpResponse<CreateChannelAPIResponse>>;
interface CreateChannelRequest {
    siweUri: string;
    domain: string;
    nonce?: string;
    notBefore?: string;
    expirationTime?: string;
    requestId?: string;
    redirectUrl?: string;
    acceptAuthAddress?: boolean;
}
interface CreateChannelAPIResponse {
    channelToken: string;
    url: string;
    nonce: string;
}
declare const createChannel: (client: Client, { ...request }: CreateChannelArgs) => CreateChannelResponse;

type AuthMethod = "custody" | "authAddress";
type FarcasterResourceParams = {
    fid: number;
};
type SignInMessageParams = Partial<SiweMessage> & FarcasterResourceParams;

interface StatusArgs {
    channelToken: string;
}
type StatusResponse = AsyncUnwrapped<HttpResponse<StatusAPIResponse>>;
interface StatusAPIResponse {
    state: "pending" | "completed";
    nonce: string;
    url: string;
    message?: string;
    signature?: `0x${string}`;
    authMethod?: AuthMethod;
    fid?: number;
    username?: string;
    bio?: string;
    displayName?: string;
    pfpUrl?: string;
    verifications?: string[];
    custody?: Hex;
    signatureParams: {
        siweUri: string;
        domain: string;
        nonce?: string;
        notBefore?: string;
        expirationTime?: string;
        requestId?: string;
        redirectUrl?: string;
    };
    metadata: {
        ip: string;
        userAgent: string;
    };
    acceptAuthAddress: boolean;
}
declare const status: (client: Client, { channelToken }: StatusArgs) => StatusResponse;

interface SiweResponse {
    success: boolean;
    data: SiweMessage;
}
type VerifyResponse = SiweResponse & FarcasterResourceParams & {
    authMethod: AuthMethod;
} & {
    data: SiweMessage;
};

interface VerifySignInMessageArgs {
    nonce: string;
    domain: string;
    message: string;
    signature: `0x${string}`;
    /**
     * @default true
     */
    acceptAuthAddress?: boolean;
}
type VerifySignInMessageResponse = Promise<Unwrapped<VerifyResponse>>;
declare const verifySignInMessage: (client: Client, { nonce, domain, message, signature, acceptAuthAddress }: VerifySignInMessageArgs) => VerifySignInMessageResponse;

interface WatchStatusArgs {
    channelToken: string;
    timeout?: number;
    interval?: number;
    onResponse?: (response: HttpResponse<StatusAPIResponse>) => void;
}
type WatchStatusResponse = AsyncUnwrapped<HttpResponse<StatusAPIResponse>>;
declare const watchStatus: (client: Client, args: WatchStatusArgs) => WatchStatusResponse;

interface AuthenticateArgs extends AuthenticateRequest {
    authKey: string;
    channelToken: string;
}
type AuthenticateResponse = AsyncUnwrapped<HttpResponse<AuthenticateAPIResponse>>;
interface AuthenticateRequest {
    message: string;
    signature: `0x${string}`;
    authMethod?: AuthMethod;
    fid: number;
    username?: string;
    bio?: string;
    displayName?: string;
    pfpUrl?: string;
}
type AuthenticateAPIResponse = StatusAPIResponse;
declare const authenticate: (client: Client, { channelToken, authKey, ...request }: AuthenticateArgs) => AuthenticateResponse;

interface BuildResponse {
    siweMessage: SiweMessage;
    message: string;
}

type BuildSignInMessageArgs = SignInMessageParams;
type BuildSignInMessageResponse = Unwrapped<BuildResponse>;
declare const buildSignInMessage: (_client: Client, args: BuildSignInMessageArgs) => BuildSignInMessageResponse;

interface ParsedSignInURI {
    channelToken: string;
}

interface ParseSignInURIArgs {
    uri: string;
}
type ParseSignInURIResponse = Unwrapped<ParsedSignInURI>;
declare const parseSignInURI: (_client: Client, { uri }: ParseSignInURIArgs) => ParseSignInURIResponse;

interface AppClient extends Client {
    createChannel: (args: CreateChannelArgs) => CreateChannelResponse;
    status: (args: StatusArgs) => StatusResponse;
    watchStatus: (args: WatchStatusArgs) => WatchStatusResponse;
    verifySignInMessage: (args: VerifySignInMessageArgs) => VerifySignInMessageResponse;
}
declare const createAppClient: (config: CreateClientArgs) => AppClient;

interface WalletClient extends Client {
    authenticate: (args: AuthenticateArgs) => AuthenticateResponse;
    buildSignInMessage: (args: BuildSignInMessageArgs) => BuildSignInMessageResponse;
    parseSignInURI: (args: ParseSignInURIArgs) => ParseSignInURIResponse;
}
declare const createWalletClient: (config: CreateClientArgs) => WalletClient;

interface ViemConfigArgs {
    rpcUrl?: string | undefined;
    rpcUrls?: string[] | undefined;
}
declare const viemConnector: (args?: ViemConfigArgs) => EthereumConnector;

export { type AppClient, type AsyncHttpResponse, type AsyncUnwrapped, type AuthClientAsyncResult, AuthClientError, type AuthClientErrorCode, type AuthClientResult, type AuthMethod, type AuthenticateAPIResponse, type AuthenticateArgs, type AuthenticateResponse, type BuildSignInMessageArgs, type BuildSignInMessageResponse, type Client, type ClientConfig, type CreateChannelAPIResponse, type CreateChannelArgs, type CreateChannelResponse, type CreateClientArgs, type FarcasterResourceParams, type HttpOpts, type HttpResponse, type NoneOf, type ParseSignInURIArgs, type ParseSignInURIResponse, type PollOpts, type SignInMessageParams, type StatusAPIResponse, type StatusArgs, type StatusResponse, type Unwrapped, type VerifySignInMessageArgs, type VerifySignInMessageResponse, type WalletClient, type WatchStatusArgs, type WatchStatusResponse, authenticate, buildSignInMessage, createAppClient, createChannel, createClient, createWalletClient, get, parseSignInURI, poll, post, status, unwrap, verifySignInMessage, viemConnector, watchStatus };
